package com.strumenta.mpsserver.logic;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SRepository;
import spark.Service;
import spark.Route;
import spark.Request;
import spark.Response;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.strumenta.mpsprotocol.data.NodeInfoDetailed;

public class ConceptRoutes {
  private SRepository repo;
  private DataExposer data;
  public ConceptRoutes(SRepository repo, DataExposer data) {
    this.repo = repo;
    this.data = data;
  }

  public void addRoutes(Service sparkService) {
    sparkService.get("/concepts/:conceptName/editor", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          final String conceptName = req.params("conceptName");

          final Wrappers._T<SNode> editorNode = new Wrappers._T<SNode>();
          repo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              SAbstractConcept concept = data.getConceptByName(conceptName);
              if (concept == null) {
                throw new NotFoundException(conceptName);
              }
              editorNode.value = ConceptUtils.findEditorForConcept(concept);
            }
          });
          if (editorNode.value == null) {
            return Server.OperationResult.failure("no editor found for concept " + conceptName);
          }
          final Wrappers._T<NodeInfoDetailed> editorData = new Wrappers._T<NodeInfoDetailed>();
          repo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              editorData.value = data.toInfoDetailed(editorNode.value);
            }
          });
          return Server.OperationResult.success(editorData.value);
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
  }
}
