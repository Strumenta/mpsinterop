package com.strumenta.mpsserver.logic;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Map;
import com.strumenta.mpsserver.extensionkit.code.Action;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import spark.Service;
import spark.Route;
import spark.Request;
import spark.Response;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import com.strumenta.mpsprotocol.data.LanguageInfo;
import com.strumenta.mpsprotocol.data.ModuleInfo;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.strumenta.mpsprotocol.data.SolutionInfo;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SModel;

public class GlobalLevelRoutes extends Routes {

  private SRepository repo;
  private DataExposer data;
  private Map<String, Map<String, Action>> conceptSpecificActions = MapSequence.fromMap(new HashMap<String, Map<String, Action>>());
  private GitFacade gitFacade;

  public GlobalLevelRoutes(SRepository repo, DataExposer data, Map<String, Map<String, Action>> conceptSpecificActions, GitFacade gitFacade) {
    this.repo = repo;
    this.data = data;
    this.conceptSpecificActions = conceptSpecificActions;
    this.gitFacade = gitFacade;
  }

  public void addRoutes(Service sparkService) {
    sparkService.get("/languages", new Route() {
      @Override
      public Object handle(Request p0, Response res) throws Exception {
        try {
          final Wrappers._T<List<LanguageInfo>> languages = new Wrappers._T<List<LanguageInfo>>();
          repo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              languages.value = data.languagesListFromRegistry();
            }
          });
          return Server.OperationResult.success(languages.value);
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.get("/modules", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          final Wrappers._T<List<ModuleInfo>> modules = new Wrappers._T<List<ModuleInfo>>();
          repo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              modules.value = data.modulesList();
            }
          });
          boolean includeReadOnly = queryFlag(req, "includeReadOnly");
          if (!(includeReadOnly)) {
            modules.value = ListSequence.fromList(modules.value).where(new IWhereFilter<ModuleInfo>() {
              public boolean accept(ModuleInfo it) {
                return !(it.getReadOnly());
              }
            }).toListSequence();
          }
          boolean includePackaged = queryFlag(req, "includePackaged");
          if (!(includePackaged)) {
            modules.value = ListSequence.fromList(modules.value).where(new IWhereFilter<ModuleInfo>() {
              public boolean accept(ModuleInfo it) {
                return !(it.getPackaged());
              }
            }).toListSequence();
          }
          return Server.OperationResult.success(modules.value);
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.get("/solutions", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          final List<String> requiredLanguageNames = ListSequence.fromList(new LinkedList<String>());
          if (req.queryParams("languages") != null) {
            ListSequence.fromList(requiredLanguageNames).addSequence(Sequence.fromIterable(Sequence.fromArray(req.queryParams("languages").split(","))));
          }
          final Wrappers._T<List<SolutionInfo>> solutions = new Wrappers._T<List<SolutionInfo>>();
          repo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              solutions.value = data.solutionsList();
            }
          });
          ListSequence.fromList(solutions.value).removeWhere(new IWhereFilter<SolutionInfo>() {
            public boolean accept(SolutionInfo s) {
              return !((s.hasAllTheseLanguages(requiredLanguageNames)));
            }
          });
          boolean includeReadOnly = queryFlag(req, "includeReadOnly");
          if (!(includeReadOnly)) {
            solutions.value = ListSequence.fromList(solutions.value).where(new IWhereFilter<SolutionInfo>() {
              public boolean accept(SolutionInfo it) {
                return !(it.getReadOnly());
              }
            }).toListSequence();
          }
          boolean includePackaged = queryFlag(req, "includePackaged");
          if (!(includePackaged)) {
            solutions.value = ListSequence.fromList(solutions.value).where(new IWhereFilter<SolutionInfo>() {
              public boolean accept(SolutionInfo it) {
                return !(it.getPackaged());
              }
            }).toListSequence();
          }
          return Server.OperationResult.success(solutions.value);
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.post("/persistence/saveAll", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          data.saveAll();
          return Server.OperationResult.success();
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.post("/persistence/reloadAll", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          data.reloadAll();
          return Server.OperationResult.success();
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());

    sparkService.get("/persistence/changedModels", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          return Server.OperationResult.success(ListSequence.fromList(data.changedModels()).select(new ISelector<SModel, String>() {
            public String select(SModel it) {
              return it.getModelName();
            }
          }).toListSequence());
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.post("/git/addAndCommit", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          if (gitFacade == null) {
            return Server.OperationResult.failure("no git configured");
          }
          gitFacade.addAllFiles();
          String message = req.body();
          if (message.isBlank()) {
            message = "commit without description";
          }
          gitFacade.commit(message);
          return Server.OperationResult.success();
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
    sparkService.post("/git/push", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          if (gitFacade == null) {
            return Server.OperationResult.failure("no git configured");
          }

          String remoteName = req.body();
          if (remoteName.isBlank()) {
            remoteName = "origin";
          }

          gitFacade.push(remoteName);
          return Server.OperationResult.success();
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e.getMessage());
        }
      }
    }, new JsonTransformer());
    sparkService.get("/git/currentBranch", new Route() {
      @Override
      public Object handle(Request req, Response res) throws Exception {
        try {
          if (gitFacade == null) {
            return Server.OperationResult.failure("no git configured");
          }
          return Server.OperationResult.success(gitFacade.currentBranch());
        } catch (Throwable e) {
          e.printStackTrace();
          return Server.OperationResult.failure(e);
        }
      }
    }, new JsonTransformer());
  }
}
